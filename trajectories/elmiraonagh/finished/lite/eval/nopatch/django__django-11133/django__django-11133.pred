{"instance_id": "django__django-11133", "model_name_or_path": "250526_anthropic_filemap_simple_review_sbl__claude-sonnet-4__experiments_logs", "model_patch": "diff --git a/django/http/response.py b/django/http/response.py\nindex 6a84e193ba..b477b42322 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -233,9 +233,23 @@ class HttpResponseBase:\n             return bytes(value)\n         if isinstance(value, str):\n             return bytes(value.encode(self.charset))\n+        # Handle objects that support the buffer protocol (e.g., memoryview, bytearray)\n+        try:\n+            memoryview(value)\n+            return bytes(value)\n+        except TypeError:\n+            pass\n         # Handle non-string types.\n         return str(value).encode(self.charset)\n \n+    def _supports_buffer_protocol(self, value):\n+        \"\"\"Check if the value supports the buffer protocol.\"\"\"\n+        try:\n+            memoryview(value)\n+            return True\n+        except TypeError:\n+            return False\n+\n     # These methods partially implement the file-like object interface.\n     # See https://docs.python.org/library/io.html#io.IOBase\n \n@@ -309,7 +323,7 @@ class HttpResponse(HttpResponseBase):\n     @content.setter\n     def content(self, value):\n         # Consume iterators upon assignment to allow repeated iteration.\n-        if hasattr(value, '__iter__') and not isinstance(value, (bytes, str)):\n+        if hasattr(value, '__iter__') and not isinstance(value, (bytes, str)) and not self._supports_buffer_protocol(value):\n             content = b''.join(self.make_bytes(chunk) for chunk in value)\n             if hasattr(value, 'close'):\n                 try:\n"}